# 给你一个数组 nums，请你从中抽取一个子序列，满足该子序列的元素之和 严格 大于未包含在该子序列中的各元素之和。 
# 
#  如果存在多个解决方案，只需返回 长度最小 的子序列。如果仍然有多个解决方案，则返回 元素之和最大 的子序列。 
# 
#  与子数组不同的地方在于，「数组的子序列」不强调元素在原数组中的连续性，也就是说，它可以通过从数组中分离一些（也可能不分离）元素得到。 
# 
#  注意，题目数据保证满足所有约束条件的解决方案是 唯一 的。同时，返回的答案应当按 非递增顺序 排列。
# 
#  
# 
#  示例 1： 
# 
#  输入：nums = [4,3,10,9,8]
# 输出：[10,9] 
# 解释：子序列 [10,9] 和 [10,8] 是最小的、满足元素之和大于其他各元素之和的子序列。但是 [10,9] 的元素之和最大。 
#  
# 
#  示例 2： 
# 
#  输入：nums = [4,4,7,6,7]
# 输出：[7,7,6] 
# 解释：子序列 [7,7] 的和为 14 ，不严格大于剩下的其他元素之和（14 = 4 + 4 + 6）。因此，[7,6,7] 是满足题意的最小子序列。注意，
# 元素按非递增顺序返回。  
#  
# 
#  示例 3： 
# 
#  输入：nums = [6]
# 输出：[6]
#  
# 
#  
# 
#  提示： 
# 
#  
#  1 <= nums.length <= 500 
#  1 <= nums[i] <= 100 
#  
#  Related Topics 贪心算法 基础排序
#  👍 24 👎 0


# leetcode submit region begin(Prohibit modification and deletion)
"""
基础排序 + 双指针：
    对数组进行降序排序，数组右侧元素依次相加，每次相加时判断，由于数组右侧元素是从大到小排列的，
因此每次相加后右侧元素之和只能是一直递增的，因此想要找到满足题意的最大子数组之和大于剩余子数组之
和，只需要找到最右侧元素相加到第一次大于剩余元素之和的子数组即可。但是如果每遍历一次最右侧元素并
累加时，都要遍历一遍剩余元素并累加，时间复杂度就变成O(N^2)，因此考虑采用双指针的方法，相向遍历
直到相遇停止，时间复杂度降为O(N)
（1）将数组按照降序排序，因为题目要求返回为非递增序列
（2）定义双指针end->0与start->nums.len-1，再用两个变量res_sum与sum记录
    剩余子元素之和与最大子元素之和，每次遍历，对应的变量都进行累加
（3）如果剩余子元素之和 小于 最大子元素之和，最右指针向左移；否则，最左指针向右移
（4）如果双指针相遇，返回指针位置之前的子数组

T: O(N*logN)
S: O(1)
"""
class Solution:
    def minSubsequence(self, nums: List[int]) -> List[int]:
        if len(nums) == 1: return nums
        nums.sort(reverse=True)
        start, end = 0, len(nums) - 1
        res_sum, sum = nums[end], nums[0]
        while not start == end:
            if res_sum < sum:
                end -= 1
                res_sum += nums[end]
            else:
                start += 1
                sum += nums[start]
        return nums[:start+1]
# leetcode submit region end(Prohibit modification and deletion)
